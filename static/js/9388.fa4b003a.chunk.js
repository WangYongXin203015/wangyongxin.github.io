"use strict";(self.webpackChunkvue=self.webpackChunkvue||[]).push([[9388],{9388:function(n,r,e){e.r(r),e.d(r,{default:function(){return D}});var l=e(6252),o=e(3577),a=(0,l._)("h4",null,"后端传文档流 下载xlsx",-1),t=[(0,l.Uk)(""),(0,l._)("code",null,"\r\n    async function download(){\r\n        const res =  await  Axios.method(URL,paramsData,{responseType:'blob'})\r\n        const blob = new Blob([res.data], { \r\n        type: 'application/vnd.ms-excel', \r\n        });\r\n        const fileName = 'fileName.xlsx';                           //为文件起名\r\n        const a = document.createElement('a');                      //模拟a标签下载\r\n        a.download = fileName;\r\n        a.style.display = 'none';\r\n        a.href = window.URL.createObjectURL(blob);                  //内存中创建连接地址\r\n        a.setAttribute('download', fileName)\r\n        document.body.appendChild(a);\r\n        a.click();\r\n        URL.revokeObjectURL(a.href);                                 // 释放URL 对象\r\n        document.body.removeChild(a);  \r\n    }\r\n\r\n    //连接下载\r\n    window.open('downloadFile');                                  \r\n    location.href = 'downloadFile';             \r\n",-1),(0,l.Uk)("\r\n")],i=(0,l._)("h4",null,"按需加载 import是异步的",-1),p=[(0,l.Uk)(""),(0,l._)("code",null,"\r\n    async function todo(){\r\n        const package =  await import('packageUrl')\r\n        todo!\r\n    }\r\n",-1),(0,l.Uk)("\r\n")],c=(0,l._)("h4",null,"vue 插槽和默认内容互斥 $slots访问插槽name判断插槽是否使用",-1),s=(0,l.Uk)(""),d=(0,l.Uk)("\r\n"),u=(0,l._)("h4",null,"页面跳转携带token",-1),m=(0,l._)("ul",null,[(0,l._)("li",null,"直接调用接口后端重定向到新页面"),(0,l._)("li",null,"window.open(url, name)， 新页面使用window.name 获取参数的值进行判断")],-1),w=(0,l._)("h4",null,"后端返回 Html",-1),f=(0,l.Uk)(""),h=(0,l.Uk)("\r\n"),g=(0,l._)("h4",null,"vue props 父组件变化 子组件 不能立即响应",-1),k=[(0,l.Uk)(""),(0,l._)("code",null,"\r\n    //1，子组件使用v-if  \r\n    // 组件初始化顺序beforeCreate  ->inject -> Props ->  Methods ->  Data -> Computed -> Watch ->provide-> created\r\n    //初始化 props 保证props 是最新的父组件传过来的值\r\n    "+(0,o.zw)('<chrild  v-if="show"></chrild>')+"\r\n    //2，使用watch监听Props 变化,等待props真正变化的时候进行操作\r\n    watch:{\r\n        props(){\r\n            todo!\r\n        }\r\n    }\r\n    //3，nexttick 等待渲染之再进行操作\r\n",-1),(0,l.Uk)("\r\n")],b=(0,l._)("h4",null,"前端 通过formdata上传文件",-1),v=[(0,l.Uk)(""),(0,l._)("code",null,'\r\n    //封装请求formdata\r\n    const upload  =  axios.post(url, params, {\r\n        headers: {\r\n           \'content-type\': \'multipart/form-data;\',\r\n        },\r\n    })\r\n    //从input 事件对象中获取文件参数并添加到formdata对象中 \r\n    const  upload = (event) =>{\r\n        let file =event.srcElement.files[0] //获取文件\r\n        let formData = new FormData(); //创建FormData对象\r\n        formData.append("file", file); //添加参数\r\n        upload(url,formData) //调用接口上传文件\r\n    }\r\n    //fetch请求\r\n    fetch("http://127.0.0.1:5500",{\r\n        method:"POST",\r\n        body:formData\r\n    })\r\n',-1),(0,l.Uk)("\r\n")],U=(0,l._)("h4",null,"压缩文件",-1),y=[(0,l.Uk)(""),(0,l._)("code",null,"\r\n    zlib 压缩\r\n    import zlib from 'zlib';\r\n    npm install node-polyfill-webpack-plugin\r\n    webpack5 package.json 添加\r\n    const NodePolyfillPlugin = require('node-polyfill-webpack-plugin')\r\n    plugins=[\r\n        ...\r\n        new NodePolyfillPlugin()\r\n    ]\r\n    //流\r\n    var gzip = zlib.createGzip();\r\n    var fs = require('fs');\r\n    var inp = fs.createReadStream('input.txt');\r\n    var out = fs.createWriteStream('input.txt.gz');\r\n    inp.pipe(gzip).pipe(out);\r\n\r\n    使用compressing包压缩\r\n    npm install compressing\r\n    npm install fs-extra //文件操作拓展包\r\n    import  compressing  from 'compressing';\r\n    import fsExtra from 'fs-extra';\r\n\r\n    promise 操作\r\n    // 压缩文件夹 \r\n    // zipFileNameEncoding解压编码格式，可以防止中文乱码\r\n    compressing.zip.compressDir('D:\\project' //压缩文件夹路径, 'D:\\project.zip' //输出压缩文件路径, { zipFileNameEncoding: 'gbk' })\r\n        .then(() => {\r\n            console.log('success');\r\n        })\r\n        .catch(err => {\r\n            console.error(err);\r\n        });\r\n    // 压缩文件\r\n    compressing.zip.compressFile('D:\\project\\1.js' //压缩文件路径, 'D:\\project\\1.zip' //输出压缩文件路径, { zipFileNameEncoding: 'gbk' })\r\n        .then(() => {\r\n            console.log('success');\r\n        })\r\n        .catch(err => {\r\n            console.error(err);\r\n        });\r\n",-1),(0,l.Uk)("\r\n")];var D=(0,l.aZ)({__name:"FAQBase",setup:function(n){return function(n,r){var e=(0,l.Q2)("code");return(0,l.wg)(),(0,l.iD)("section",null,[a,(0,l.wy)(((0,l.wg)(),(0,l.iD)("pre",null,t)),[[e]]),i,(0,l.wy)(((0,l.wg)(),(0,l.iD)("pre",null,p)),[[e]]),c,(0,l.wy)(((0,l.wg)(),(0,l.iD)("pre",null,[s,(0,l._)("code",null,"\r\n   "+(0,o.zw)(' <div  class="default" v-if="!$slots.default"></div>\n    <slot name="default"></slot>')+"\r\n",1),d])),[[e]]),u,m,w,(0,l.wy)(((0,l.wg)(),(0,l.iD)("pre",null,[f,(0,l._)("code",null,'\r\n    //打开新页面 渲染返回数据\r\n    var newPage = window.open("about:blank", "_blank");\r\n    newPage.document.write(response.data);\r\n    //文本中保存到流中，生成url，a 标签模拟点击 请求\r\n    var downloadUrl = window.URL.createObjectURL(data);\r\n    var a = document.createElement("a");\r\n    a.href = downloadUrl;\r\n    a.click()\r\n    //使用inner-html属性 v-html\r\n    '+(0,o.zw)('<div v-html="response.data"></div>')+"\r\n    //后端返回新页面，前端访问\r\n    window.location.href=path\r\n    //后端sendRedirect \r\n",1),h])),[[e]]),g,(0,l.wy)(((0,l.wg)(),(0,l.iD)("pre",null,k)),[[e]]),b,(0,l.wy)(((0,l.wg)(),(0,l.iD)("pre",null,v)),[[e]]),U,(0,l.wy)(((0,l.wg)(),(0,l.iD)("pre",null,y)),[[e]])])}}})}}]);