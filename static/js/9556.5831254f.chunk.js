"use strict";(self.webpackChunkvue=self.webpackChunkvue||[]).push([[9556],{49556:function(n,e,r){r.r(e),r.d(e,{default:function(){return v}});var t=r(66252),s=(0,t._)("h4",null,"单例模式",-1),i=[(0,t.Uk)(""),(0,t._)("code",null,"\r\n    //饿汉模式\r\n    namespace E{\r\n        class Singleton {\r\n            private name: string;\r\n            private static instance: Singleton = new Singleton('singleton');\r\n            private constructor(name: string) {\r\n                this.name = name;\r\n                // TODO 初始化逻辑\r\n            }\r\n            public static getInstance(): Singleton {\r\n                return Singleton.instance;\r\n            }\r\n        }\r\n        Singleton.getInstance();  // singleton、\r\n    }\r\n    //懒汉模式 需要时再创造\r\n    namespace L{\r\n        class Singleton {\r\n            name:any\r\n            static instance: any; //声明\r\n            constructor(name:any) {\r\n                this.name = name;\r\n                // TODO 初始化逻辑\r\n            }\r\n            static getInstance() { //需要的时候创建，有就不创建了\r\n                if (!Singleton.instance) {\r\n                    Singleton.instance = new Singleton('singleton');\r\n                }\r\n                return Singleton.instance;\r\n            }\r\n        }\r\n        Singleton.getInstance(); // singleton\r\n    }\r\n",-1),(0,t.Uk)("\r\n")],a=(0,t._)("h4",null,"观察者模式",-1),l=[(0,t.Uk)(""),(0,t._)("code",null,'\r\n    //观察者 一对多 一个被观察者 被多个观察者观察\r\n    //被观察者更新  观察者触发响应的行为\r\n    class Observer {\r\n        name:String\r\n        constructor(name:String){\r\n            this.name=name\r\n        }\r\n        change(params:any){\r\n            console.log(params);\r\n        }\r\n    }\r\n\r\n    // 被观察者\r\n    class Subject {\r\n        private  data={}\r\n        private observer:  Observer []=[] //依赖数组\r\n        public get data() : any {//调用get 收集依赖及添加观察者 并传出回调\r\n            this.observer.push(new Observer(""))\r\n            return this.data\r\n        }\r\n\r\n        public set data(v : any) { //调用set 触发观察者 完成观察者的其他行为\r\n            this.data = v; \r\n            this.observer.forEach(item=>{ //遍历依赖 完成观察者的其他行为\r\n                item.change(item)\r\n            })\r\n        }\r\n    }\r\n',-1),(0,t.Uk)("\r\n")],c=(0,t._)("h4",null,"订阅发布模式",-1),f=[(0,t.Uk)(""),(0,t._)("code",null,'\r\n    // 发布订阅模式  eventbus 就是订阅发布模式 \r\n    //一个event 可以绑定多个事件\r\n    //统一调度 完全解耦\r\n    const eventObj={} as any;//定义事件对象\r\n    eventObj.list = {}as any; //缓存事件对象\r\n    //绑定事件\r\n    eventObj.on =  (event:string,  fn:(params:any)=>void) =>{\r\n        // 如果对象中没有对应的 event 值，也就是说明没有订阅过，就给 event 创建个缓存列表\r\n        // 如有对象中有相应的 event 值，把 fn 添加到对应 event 的缓存列表里\r\n        eventObj.list[event] || (eventObj.list[event]=[] as any []).push(fn)\r\n        return eventObj\r\n    }\r\n    //触发事件\r\n    eventObj.emit = (event:string,params:any) => {\r\n        let fns = [...eventObj.list[event]];//获取事件对应的函数列表\r\n        if (!fns || fns.length === 0) {\r\n            return false;\r\n        }\r\n        fns.forEach(fn => { //有函数就执行函数\r\n            fn.call(eventObj, params); \r\n        });\r\n        return eventObj\r\n    };\r\n    //仅一次的事件\r\n    eventObj.once =  (event:string, fn:(params:any)=>void) =>{\r\n        function once() { \r\n            eventObj.on("once", fn) //订阅 once 执行 \r\n            eventObj.emit("once") //出发 once\r\n            eventObj.off(event, once) //移除事件订阅 \r\n        }\r\n        eventObj.on(event, once) //订阅\r\n        return eventObj\r\n    }\r\n    //移出事件\r\n    eventObj.off = (event:string,fn:(params:any)=>void) => {\r\n        let fns = eventObj.list[event]; \r\n        // 如果缓存列表中没有相应的 fn，返回false\r\n        if (!fns) return false;\r\n        if (!fn) {\r\n            // 如果没有传 fn 的话，就会将 event 值对应缓存列表中的 fn 都清空\r\n            fns && (fns.length = 0);\r\n        } else {\r\n            // 若有 fn，遍历缓存列表，看看传入的 fn 与哪个函数相同，如果相同就直接从缓存列表中删掉即可\r\n            let cb;\r\n            for (let i = 0, i  < fns.length; i++) {\r\n                cb = fns[i];\r\n                if (cb === fn || cb.fn === fn) {\r\n                    fns.splice(i, 1);\r\n                    break\r\n                }\r\n            }\r\n        }\r\n        return eventObj;\r\n    };\r\n    //事件调度也是 发布订阅模式\r\n    class EventDispatcher {\r\n        listeners : undefined | object //事件以及对应的函数合集\r\n        //添加事件\r\n        addEventListener( type:string, listener:Function ) {\r\n            if ( this.listeners === undefined ) this.listeners = {};\r\n            const listeners = this.listeners;\r\n            if ( listeners[ type ] === undefined ) {\r\n                listeners[ type ] = [];\r\n            }\r\n            if ( listeners[ type ].indexOf( listener ) === - 1 ) {\r\n                listeners[ type ].push( listener );\r\n            }\r\n        }\r\n        //判断是否已存在\r\n        hasEventListener( type:string, listener:Function ) {\r\n            if ( this.listeners === undefined ) return false;\r\n            const listeners = this.listeners;\r\n            return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;\r\n        }\r\n        //移除事件\r\n        removeEventListener( type:string, listener:Function ) {\r\n            if ( this.listeners === undefined ) return;\r\n            const listeners = this.listeners;\r\n            const listenerArray = listeners[ type ];\r\n            if ( listenerArray !== undefined ) {\r\n                const index = listenerArray.indexOf( listener );\r\n                if ( index !== - 1 ) {\r\n                    listenerArray.splice( index, 1 );\r\n                }\r\n            }\r\n        }\r\n\r\n        //触发事件\r\n        dispatchEvent(event: {type: string,target: null | EventDispatcher}={type:"",target:null}) {\r\n            if ( this.listeners === undefined ) return;\r\n            const listeners = this.listeners;\r\n            const listenerArray = listeners[ event.type ];\r\n            if ( listenerArray !== undefined ) {\r\n                event.target = this;\r\n                const array = listenerArray.slice( 0 );\r\n                for ( let i = 0, l = array.length; i < l; i ++ ) {\r\n                    array[ i ].call( this, event );\r\n                }\r\n                event.target = null;\r\n            }\r\n        }\r\n    }\r\n',-1),(0,t.Uk)("\r\n")];const o={};var v=(0,r(83744).Z)(o,[["render",function(n,e){var r=(0,t.Q2)("code");return(0,t.wg)(),(0,t.iD)("section",null,[s,(0,t.wy)(((0,t.wg)(),(0,t.iD)("pre",null,i)),[[r]]),a,(0,t.wy)(((0,t.wg)(),(0,t.iD)("pre",null,l)),[[r]]),c,(0,t.wy)(((0,t.wg)(),(0,t.iD)("pre",null,f)),[[r]])])}]])}}]);