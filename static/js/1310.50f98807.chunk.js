"use strict";(self.webpackChunkvue=self.webpackChunkvue||[]).push([[1310],{41310:function(l,i,t){t.r(i),t.d(i,{default:function(){return o}});var e=t(66252),u=[(0,e.uE)("<h4>React的严格模式如何使用，有什么用处？</h4><ul><li>识别不安全的生命周期</li><li>关于使用过时字符串 ref API 的警告</li><li>关于使用废弃的 findDOMNode 方法的警告</li><li>检测意外的副作用</li><li>检测过时的 context API</li></ul><h4>React.Children.map和js的map有什么区别？</h4><ul><li> JavaScript中的map不会对为null或者undefined的数据进行处理</li><li>React.Children.map中的map可以处理React.Children为null或者undefined的情况</li></ul><h4>高阶组件</h4><ul><li>装饰模式 不改变装饰对象本身</li><li>组件作为参数 返回包转后的组件</li><li>属性穿透 props 也必须传下去 不然会有属性缺失</li></ul><h4>render模式</h4><ul><li>逻辑组件接受参数 返回处理后的数据</li><li>使用的地方提供布局 并接受返回值</li><li>只能在return 中访问到数据</li></ul><h4>hook</h4><ul><li>逻辑直接拿来复用</li><li>生命周期无关</li><li>嵌套深渊</li><li>不需要this 告别class</li></ul><h4>为什么调用 setState 而不是直接改变 state？</h4><ul><li>修改state并不能触发更新</li><li>多次连续调用setState 会合并成一次状态修改</li><li>依赖变化后的值需要在setState中传入回调函数</li><li>不可变对象的修改会返回一个新的对象，不用担心原对象在不小心的情况下修改导致的错误，方便程序的管理和调试。</li><li>在组件的shouldComponentUpdate方法中仅需要比较前后两次状态对象的引用就可以判断状态是否真的改变，从而避免不必要的render调用。</li></ul><h4>受控组件和非控组件</h4><ul><li>受控组件 为每个状态编写一个事件处理程序</li><li>非控组件 不需要每个状态编写一个事件处理程序</li></ul><h4>React-Router的实现原理是什么？</h4><ul><li>URL 与 UI 界面的同步</li><li>监听路由变化 匹配对应的component</li><li>触发跳转 -&gt;生成路由对象-&gt; 原生操作url URL更新 -&gt;执行回调进行匹配-&gt;根据新的状态渲染页面-&gt;UI更新</li></ul><h4> H5 history </h4><ul><li>history.back() 后退一个页面</li><li>history.forward() 进入历史的下一个页面</li><li>history.go(step) 正为前进 ，负为后退</li><li>history.pushState(state, title, url) 不刷新页面添加一条历史记录，url为新地址，title，state会被浏览器忽略</li><li>history.replaceState(state, title, url) 替换当前地址栏里的url</li></ul><h4>Redux</h4><ul><li>Action 描述操作行为 包括type payload</li><li>type Action类型 payload 参数</li><li>Reducer 真正执行的行为</li><li>Store 管理action 和 reducer 及其关系的对象</li><li>访问 监听action的发布 更新状态 支持订阅store的变更</li><li>对异步的支持不是很好</li><li>每次更新state 都会产生一个新的state</li></ul><h4>Redux 中间件原理</h4><ul><li>中间件本质时一个柯里化函数</li><li>(payload) =&gt; (dispatch) =&gt; {todo!}</li><li>外层函数异步 内部返回的函数真实触发action </li></ul><h4>Redux/Toolkit</h4><ul><li>Redux 对异步进行支持 切片工具</li><li>name 命名空间</li><li>initialState 初始化对象</li><li>reducers 导出为action</li><li>async 导出为异步action</li><li>Provider 组件 注入store </li><li>useSelector 获取state里面的参数</li><li> useDispatch 派发action</li></ul><h4>hooks</h4><ul><li>状态较少时可以直接使用 hooks 进行状态管理</li></ul><h4>hook</h4><ul><li>useState 简单状态管理 返回一个元组 第一个是当前状态，第二个是状态修改方法</li><li>useRef 获取组件和最新数据</li><li>useReducer 类似rudex</li><li>useEffect 渲染之后执行的操作 返回清除函数执行清除副作用 组件卸载时清除</li><li>useContext 订阅上层传递下来的值</li><li>useCallback 可以类似与watch</li><li>useMemo 类似计算属性</li><li>useImperativeHandle 自定义暴露的实例值</li><li>useLayoutEffect 所有dom更新后同步调用</li></ul><h4>合成事件</h4><ul><li>兼容性好</li><li>事件注册最后会绑定到docment上 节省内存开销</li><li>docment 对象随时可用，可以随时添加事件，减少事件处理数量</li><li>节省了dom引用，减少整个页面所需要的内存，相同处理函数只需要添加一个函数即可</li></ul><h4>为什么类方法需要绑定到类实例？</h4><ul><li>js中this会根据上下文变化</li><li>使用箭头函数 或者bind 将this 绑定在类实例上</li></ul>",32)];const a={};var o=(0,t(83744).Z)(a,[["render",function(l,i){return(0,e.wg)(),(0,e.iD)("section",null,u)}]])}}]);