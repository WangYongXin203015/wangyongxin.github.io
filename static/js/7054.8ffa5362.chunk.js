"use strict";(self.webpackChunkvue=self.webpackChunkvue||[]).push([[7054],{67054:function(l,i,u){u.r(i),u.d(i,{default:function(){return r}});var t=u(66252),e=[(0,t.uE)("<h4>环境搭建</h4><ul><li>官网下载rustup-init.exe</li><li>安装VS</li><li>运行rustup-init.exe</li><li>编写第一个rust程序</li><li>创建main.rs</li><li>fn main(){println!(&quot;hello world&quot;)}</li><li>运行code run 打印台输出hello world</li></ul><h4>数据类型</h4><ul><li>整数类型：i8，u8,i16,u16,...i128,u128,isize,usize</li><li>浮点：f32,f64 f64精度更高，计算速度近乎相同</li><li>布尔类型 ：true ，false</li><li>字符型： char 代表Unicode标量值，单引号，仅包含一个字符，支持emoji表情，几乎所有的人类语言都支持</li><li>元组(),确定的类型和大小，可以组合不同的类型，通过.index访问</li><li>数组 单一类型的多个变量的集合，类型和大小确定，通过[index]访问</li><li>单元类型() 相当于void</li></ul><h4>语句和表达式</h4><ul><li>语句和表达式</li><li>语句是执行某些操作并没有返回值</li><li>表达式有计算步骤并且有返回值，表达式可以当做返回值返回可以省略return</li><li>语句就是计算结果为()的特殊表达式。</li><li>表达式用来计算求值。以；结尾</li><li>编译时如果碰到分号，就会继续往后执行。</li><li>如果遇到语句，就执行语句；</li><li>如果遇到表达式，则会对表达式求值；</li><li>如果分号后面什么都没有，就补上()</li></ul><h4>函数</h4><ul><li>函数可以嵌套</li><li>函数标注 fn fnNAme(params:Type1)-&gt;Type2{ return value:Type2 } </li>\x3c!-- &lt;li&gt;rust 没有++ 这不符合rust设计理念&lt;/li&gt; --\x3e</ul><h4>enum，Option，Rusult，</h4><ul><li>enum 普通枚举</li><li>枚举可以实现</li><li>Option 可以处理空值的枚举</li><li>Rusult 可以处理错误的枚举</li></ul><h4>结构体 Struct</h4><ul><li>Rust没有类可以用Struct 模拟类</li><li>结构体类似Interface</li><li>使用 trait 实现多台可以给定义的结构体实现自己的trait</li><li>继承 在子Struct定义中实现一个父Struct的实例 实现继承可以定义成</li><li>元组结构体 处理简单的，多次复用的数据，相当于实现一个元组的工厂</li><li>单元结构体 不需要任何成员 仅有定义和实现trait 没有成员 单元() </li></ul><h4>所有权</h4><ul><li>Rust 中的每一个值都有一个被称为其 所有者（owner）的变量。</li><li>值有且只有一个所有者。</li><li>当所有者（变量）离开作用域，这个值将被丢弃。</li><li>move 当变量赋值给另一个变量 当前变量获得值的所有权</li><li>函数接受变量 值也会move</li><li>想在函数内使用值不改变所有权 可以借用，引用，对值Clone，或者在函数执行完返回原值</li><li>实现了Copy 类型会自动进行深拷贝不会进行move</li><li>借用和引用 借用函数参数传引用 引用 作用域内将值的引用赋值给其他变量只能有一个可变引用，或者多个不可变引用 引用的值必须有效</li></ul>",14)];const n={};var r=(0,u(83744).Z)(n,[["render",function(l,i){return(0,t.wg)(),(0,t.iD)("section",null,e)}]])}}]);