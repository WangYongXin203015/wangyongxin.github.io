"use strict";(self.webpackChunkvue=self.webpackChunkvue||[]).push([[504],{5504:function(l,i,e){e.r(i),e.d(i,{default:function(){return h}});var t=e(6252),u=[(0,t.uE)("<h4>React的严格模式如何使用，有什么用处？</h4><ul><li>识别不安全的生命周期</li><li>关于使用过时字符串 ref API 的警告</li><li>关于使用废弃的 findDOMNode 方法的警告</li><li>检测意外的副作用</li><li>检测过时的 context API</li></ul><h4>React.Children.map和js的map有什么区别？</h4><ul> JavaScript中的map不会对为null或者undefined的数据进行处理，而React.Children.map中的map可以处理React.Children为null或者undefined的情况 </ul><h4>高阶组件</h4><ul><li>装饰模式 不改变装饰对象本身</li><li>组件作为参数 返回包转后的组件</li><li>属性穿透 props 也必须传下去 不然会有属性缺失</li></ul><h4>render模式</h4><ul><li>逻辑组件接受参数 返回处理后的数据</li><li>使用的地方提供布局 并接受返回值</li></ul><h4>hook</h4><ul><li>逻辑直接拿来复用</li></ul><h4>为什么调用 setState 而不是直接改变 state？</h4><ul><li>修改state并不能触发更新</li><li>多次连续调用setState 会合并成一次状态修改</li><li>依赖变化后的值需要在setState中传入回调函数</li><li>不可变对象的修改会返回一个新的对象，不用担心原对象在不小心的情况下修改导致的错误，方便程序的管理和调试。</li><li>在组件的shouldComponentUpdate方法中仅需要比较前后两次状态对象的引用就可以判断状态是否真的改变，从而避免不必要的render调用。</li></ul><h4>受控组件和非控组件</h4><ul><li>受控组件 为每个状态编写一个事件处理程序</li><li>非控组件 不需要每个状态编写一个事件处理程序</li></ul><h4>React-Router的实现原理是什么？</h4><ul><li>hash 监听路由变化 匹配对应的component</li><li>history </li></ul>",16)];const n={};var h=(0,e(3744).Z)(n,[["render",function(l,i){return(0,t.wg)(),(0,t.iD)("section",null,u)}]])}}]);