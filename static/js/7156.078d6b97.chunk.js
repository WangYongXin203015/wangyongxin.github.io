"use strict";(self.webpackChunkvue=self.webpackChunkvue||[]).push([[7156],{27156:function(l,i,e){e.r(i),e.d(i,{default:function(){return r}});var t=e(66252),u=[(0,t.uE)("<h4>React的严格模式如何使用，有什么用处？</h4><ul><li>识别不安全的生命周期</li><li>关于使用过时字符串 ref API 的警告</li><li>关于使用废弃的 findDOMNode 方法的警告</li><li>检测意外的副作用</li><li>检测过时的 context API</li></ul><h4>React.Children.map和js的map有什么区别？</h4><ul><li> JavaScript中的map不会对为null或者undefined的数据进行处理</li><li>React.Children.map中的map可以处理React.Children为null或者undefined的情况</li></ul><h4>高阶组件</h4><ul><li>装饰模式 不改变装饰对象本身</li><li>组件作为参数 返回包转后的组件</li><li>属性穿透 props 也必须传下去 不然会有属性缺失</li></ul><h4>render模式</h4><ul><li>逻辑组件接受参数 返回处理后的数据</li><li>使用的地方提供布局 并接受返回值</li><li>只能在return 中访问到数据</li></ul><h4>hook</h4><ul><li>逻辑直接拿来复用</li><li>生命周期无关</li><li>嵌套深渊</li><li>不需要this 告别class</li></ul><h4>为什么调用 setState 而不是直接改变 state？</h4><ul><li>setState 的功能 更改this.state，触发更新，合并更新 </li><li>修改state并不能触发更新</li><li>多次连续调用setState 会合并成一次状态修改</li><li>依赖变化后的值需要在setState中传入回调函数</li><li>不可变对象的修改会返回一个新的对象，不用担心原对象在不小心的情况下修改导致的错误，方便程序的管理和调试。</li><li>在组件的shouldComponentUpdate方法中仅需要比较前后两次状态对象的引用就可以判断状态是否真的改变，从而避免不必要的render调用。</li></ul><h4>受控组件和非控组件</h4><ul><li>受控组件 为每个状态编写一个事件处理程序</li><li>表单组件 用户输入时 监听onchange 事件 更新组件状态 即可称为可控组件</li><li>非控组件 不需要每个状态编写一个事件处理程序</li><li>使用ref 获取DOM的值</li><li>受控组件支持字段即时验证</li></ul><h4>React-Router的实现原理是什么？</h4><ul><li>URL 与 UI 界面的同步</li><li>监听路由变化 匹配对应的component</li><li>触发跳转 -&gt;生成路由对象-&gt; 原生操作url URL更新 -&gt;执行回调进行匹配-&gt;根据新的状态渲染页面-&gt;UI更新</li></ul><h4> H5 history </h4><ul><li>history.back() 后退一个页面</li><li>history.forward() 进入历史的下一个页面</li><li>history.go(step) 正为前进 ，负为后退</li><li>history.pushState(state, title, url) 不刷新页面添加一条历史记录，url为新地址，title，state会被浏览器忽略</li><li>history.replaceState(state, title, url) 替换当前地址栏里的url</li></ul><h4>Redux</h4><ul><li>Action 描述操作行为 包括type payload</li><li>type Action类型 payload 参数</li><li>Reducer 真正执行的行为</li><li>Store 管理action 和 reducer 及其关系的对象</li><li>访问 监听action的发布 更新状态 支持订阅store的变更</li><li>对异步的支持不是很好</li><li>每次更新state 都会产生一个新的state</li></ul><h4>Redux 中间件原理</h4><ul><li>中间件本质时一个柯里化函数</li><li>(payload) =&gt; (dispatch) =&gt; {todo!}</li><li>外层函数异步 内部返回的函数真实触发action </li></ul><h4>Redux/Toolkit</h4><ul><li>Redux 对异步进行支持 切片工具</li><li>name 命名空间</li><li>initialState 初始化对象</li><li>reducers 导出为action</li><li>async 导出为异步action</li><li>Provider 组件 注入store </li><li>useSelector 获取state里面的参数</li><li> useDispatch 派发action</li></ul><h4>hooks</h4><ul><li>状态较少时可以直接使用 hooks 进行状态管理</li></ul><h4>hook</h4><ul><li>useState 简单状态管理 返回一个元组 第一个是当前状态，第二个是状态修改方法</li><li>useRef 获取组件和最新数据</li><li>useReducer 类似rudex</li><li>useEffect 渲染之后执行的操作 返回清除函数执行清除副作用 组件卸载时清除</li><li>useContext 订阅上层传递下来的值</li><li>useCallback 可以类似与watch</li><li>useMemo 类似计算属性</li><li>useImperativeHandle 自定义暴露的实例值</li><li>useLayoutEffect 所有dom更新后同步调用</li></ul><h4>合成事件</h4><ul><li>兼容性好</li><li>事件注册最后会绑定到docment上 节省内存开销</li><li>docment 对象随时可用，可以随时添加事件，减少事件处理数量</li><li>节省了dom引用，减少整个页面所需要的内存，相同处理函数只需要添加一个函数即可</li></ul><h4>为什么类方法需要绑定到类实例？</h4><ul><li>js中this会根据上下文变化</li><li>使用箭头函数 或者bind 将this 绑定在类实例上</li></ul><h4>refs</h4><ul><li>在render 之后访问DOM或React元素的方法 refs </li><li>类组件使用 this.refs.myInput</li><li>也可以使用React.createRef() 创建变量绑定到dom 或react 元素上</li><li>函数组件 使用 函数获取 DOM 闭包实现</li><li>useRef 创建一个组件声明周期内的可变变量 变量 配合ref 可以 获取DOM 元素</li></ul><h4>state和props </h4><ul><li>state组件内部状态</li><li>prpos 是外部传入数据，不可变</li></ul><h4>在构造函数调用 super 并将 props 作为参数传入的作用是啥？</h4><ul><li>在构造函数中访问 prpos</li></ul><h4>React.createElement 和jsx</h4><ul><li>React.createElement 方法第一个参数是tag 第二个参数是props ,第三个参数是文本，后面的参数是children</li><li>jsx 是React.createElement 的语法糖 使用时 需要配置babel 和webpack 将jsx代码解释成js</li></ul><h4>生命周期</h4><ul><li>Initialization 初始化阶段 <ul><li> constructor 初始化state prpos</li></ul></li><li>Mounting 挂载阶段 <ul><li> componentWillMount</li><li> render</li><li> componentDidMount</li></ul></li><li>Updating 更新阶段 <ul><li>componentWillReceiveProps 当props更新时触发</li><li>shouldComponentUpdate 是否更新用于性能优化</li><li>componentWillUpdate shouldComponentUpdate返回为true时触发</li><li>render</li><li>componentDidUpdate</li></ul></li><li>Unmounting 卸载阶段 componentWillUnmount 卸载组件释放资源</li></ul><h4>为什么类方法需要绑定到类实例</h4><ul><li>js 的this比较灵活 将方法绑定到class实例上 固定方法的上下文</li><li>通常在constructor 中完成</li></ul><h4>prop drilling 和 React Context?</h4><ul><li>组件嵌套时props 必须一层层传递下去 不然props 会丢失 传递下去 即为 prop drilling</li><li>Provider 组件和 Consumer组件 和 useContext 获取传递的值 </li><li>React Context? 避免了数据穿透</li><li>使用 createContext 创建需要穿透的属性</li><li>Context.Provider 组件value 属性 重新赋值</li><li> Context.Consumer 组件 通过Context获取传递的属性</li><li>类组件 使用 静态属性 每个地方都能访问</li><li>函数组件 props， context 第二个参数 获取 context</li><li>Context的父组件渲染时，子组件也会渲染 所以 Context 常用于管理全局状态</li></ul><h4>什么是 React Fiber?</h4><ul><li>对vnode的优化升级</li><li>不会让一个任务长期占据线程 任务优先级</li><li>requestAnimationFrame 高优先级任务</li><li>requestIdleCallback 低优先级任务</li><li>对任务进行细化用户体验更细腻</li></ul><h4>如何在 ReactJS 的 Props上应用验证？</h4><ul><li>prop-types 插件</li><li>可以定义props的类型 以及isRequired</li><li>ts 可以定义interface 校验</li></ul><h4>getInitialState 和 constructor</h4><ul><li>es6 constructor</li><li>es5 getInitialState</li></ul><h4>如何有条件地向 React 组件添加属性？</h4><ul><li> 标签内使用 {} 写入条件</li></ul><h4>Hooks会取代 render props 和高阶组件吗</h4><ul><li> 大部分情况下 hooks 可以替代 render props 和高阶组件</li><li></li></ul>",56)];const o={};var r=(0,e(83744).Z)(o,[["render",function(l,i){return(0,t.wg)(),(0,t.iD)("section",null,u)}]])}}]);