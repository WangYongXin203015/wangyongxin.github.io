"use strict";(self.webpackChunkvue=self.webpackChunkvue||[]).push([[4632],{4632:function(l,i,e){e.r(i),e.d(i,{default:function(){return n}});var u=e(6252),a=[(0,u.uE)('<h4>什么是bundle,什么是chunk，什么是module?</h4><ul><li>bundle是由webpack打包出来的文件</li><li>chunk是指webpack在进行模块的依赖分析的时候，代码分割出来的代码块</li><li>module是开发中的单个模块。</li></ul><h4>什么是Loader?什么是Plugin?</h4><ul><li>loader 是使wenbpack拥有加载和解析非js文件的能力</li><li>loader 再module.rules中配置 里面描述了对于什么类型的文件（test），使用什么加载(loader)和使用的参数（options）</li><li>plugin 可以扩展webpack的功能，使得webpack更加灵活。可以在构建的过程中通过webpack的api改变输出的结果</li><li>plugin 在plugins中单独配置 类型为数组，每一项是一个plugin的实例，参数都通过构造函数传入。</li></ul><h4>Webpack的构建流程</h4><ul><li>初始化参数 shell和config文件中获取参数并合并</li><li>开始编译 使用初始化参数得到初始complier对象，加载所有配置的插件，执行run方法开始编译</li><li>确定入口文件</li><li>编译模块 (Make) 从入口文件触发调用loader对模块进行编译，找到模块依赖进行处理</li><li>完成编译，得到每个模块被编译后的最终内容和依赖关系</li><li>输出资源 (Seal)根据入口和模块之间的依赖关系，组装成一个个包含多个模块的chunk，在把每个chunk转换成一个单独的文件加载到输出列表</li><li>输出完成 确定出口路径和文件名，把内容写到系统中</li></ul><h4>如何利用webpack来优化前端性能</h4><ul class="important"><li>提取公共代码</li><li>压缩代码</li><li>cnd加速</li><li>Tree Shaking树摇 删除死代码</li><li>使用loader的时候，使用exclude排除node_modules中的文件</li><li>文件压缩ComepressionPlugin</li><li>代码分离 按需加载 或者并行加载</li></ul><h4>如何提高webpack的构建速度？</h4><ul><li>CommonsChunkPlugin提取公共代码</li><li>通过externals配置来提取常用库</li><li>使用Tree-shaking和Scope Hoisting来剔除多余代码</li></ul><h4>webpack-dev-server和http服务器如nginx有什么区别?</h4><ul><li>webpack-dev-server使用内存来存储webpack开发环境下的打包文件</li><li>并且可以使用模块热更新</li><li>他比传统的http服务对开发更加简单高效。</li><li>模块热更新 不需要自己更新页面</li></ul><h4>长缓存优化</h4><ul><li>给打包文件起名字，分离经常更新的代码和框架代码</li><li>NameModulesPlugin 或 HashedModuleIdsPlugin 使再次打包文件名不变</li></ul><h4>常见的Lodaer</h4><ul><li>babel-loader js兼容</li><li>css-loader，style-loader 把css代码注入到js代码中</li><li>source-map-loader 方便调试开发用</li><li>postcss-loader 处理兼容css autoprefixer </li></ul><h4>常用的Plugin</h4><ul><li>html-webpack-plugin 简化 html 文件创建 根据模板创建打包的html文件</li><li>optimize-css-assets-webpack-plugin 压缩css</li><li>mini-css-extract-plugin 分离样式文件，css文件提取，支持按需加载</li><li>clean-webpack-plugin 清理打包目录</li><li>webpack-bundle-analyzer 分析包管理</li><li>webpack-merge 分离config</li></ul><h4>是否写过Loader和Plugin？描述一下编写loader或plugin的思路？</h4><ul><li>loader 只做转义工作 每个loader拿到源文件内容通过返回值输出 也可以使用this.callback()返回</li><li>loader 本质是函数</li><li>Plugin webpack 在运行生命周期会广播事件 Plugin监听事件 在合适的时机通过webpack提供的api改变输出结果</li><li>Plugin 基于事件流框架Tapable</li><li>consturctor 获取参数，apply()得到compiler，</li></ul><h4>webpack5自带功能</h4><ul><li>asset 处理文件</li><li>Tree-shaking <ul><li>Tree-shaking 基于ES module </li><li>Make 阶段，收集模块导出变量并记录到模块依赖关系图 ModuleGraph 变量中</li><li>Seal 阶段，遍历 ModuleGraph 标记模块导出变量有没有被使用</li><li>生成产物时，若变量没有被其它模块使用则删除对应的导出语句</li></ul></li></ul><h4>热模块更新</h4><ul><li>通过webpack-dev-server创建两个服务器：提供静态资源的服务（express）和Socket服务</li><li>express server 负责直接提供静态资源的服务（打包后的资源直接被浏览器请求和解析）</li><li>socket server 是一个 websocket 的长连接，双方可以通信</li><li>当 socket server 监听到对应的模块发生变化时，会生成两个文件.json（manifest文件）和.js文件（update chunk）</li><li>通过长连接，socket server 可以直接将这两个文件主动发送给客户端（浏览器）</li><li>浏览器拿到两个新的文件后，通过HMR runtime机制，加载这两个文件，并且针对修改的模块进行更新</li></ul><h4>webpack多页面打包</h4><ul><li>每个页面添加独立的入口文件</li><li>入口文件添加多个入口</li><li>配置多个html 模板 如果分开部署 可以不配置 </li></ul>',26)];const s={};var n=(0,e(3744).Z)(s,[["render",function(l,i){return(0,u.wg)(),(0,u.iD)("section",null,a)}]])}}]);