"use strict";(self.webpackChunkvue=self.webpackChunkvue||[]).push([[155],{40155:function(l,i,e){e.r(i),e.d(i,{default:function(){return c}});var t=e(66252),n=[(0,t.uE)("<h4>TypeScript 是什么</h4><ul><li>TypeScript是JavaScript 的类型超集</li><li>TypeScript需要编译成JavaScript在浏览器环境运行</li></ul><h4>TypeScript 特性</h4><ul><li>类型批注和编译时类型检查 ：在编译时批注变量类型</li><li>类型推断：ts 中没有批注变量类型会自动推断变量的类型</li><li>类型擦除：在编译过程中批注的内容和接口会在运行时利用工具擦除</li><li>接口：ts 中用接口来定义对象类型</li><li>枚举：用于取值被限定在一定范围内的场景</li><li>Mixin：可以接受任意类型的值</li><li>泛型编程：写代码时使用一些以后才指定的类型</li><li>命名空间：命名只在该区域内有效，其他区域可重复使用该名字而不冲突</li><li>元组：元组合并了不同类型的对象，相当于一个可以装不同类型数据的数组</li></ul><h4>数据类型</h4><ul><li>tuple 元组 类型和数量确定的数组</li><li>enum 枚举不指定值是数字枚举 <div>enum Direction {Up,Down,Left,Right}，Up=0，Down=1</div><div>enum Direction {Up=1,Down=&quot;111&quot;,Left,Right}，Up=1，Down=111</div></li><li>void 空值</li><li>never 不会出现的值</li><li>any 任意类型</li></ul><h4>interface</h4><ul><li>接口是一系列抽象方法的声明，是一些方法特征的集合，不需要实现</li><li>可选属性 ？ </li><li>只读属性 readonly </li><li>函数只写标识 不需要实现</li><li>接口可以合并 可以实现</li></ul><h4>class</h4><ul><li>与ES6 的class类似</li><li>abstract class 抽象类</li><li>静态属性 class本身的属性和方法</li><li>class Classname implements InterfaceA, InterfaceB 可以继承多个父类</li></ul><h4>泛型</h4><ul><li>只用在使用时 确定类型</li><li>类型约束</li></ul><h4>高级类型</h4><ul><li>交叉类型 U &amp; T 多个类型合并为一个类型 ，本质上是一种并的操作</li><li>联合类型 U | T 多个类型中的任意一个，本质上是一种交的操作</li><li>类型别名 type 给类型起别名</li><li>类型约束 T extends BaseType 只能传入约束类型中的变量类型</li><li>映射类型 通过 in 关键字做类型的映射，遍历已有接口的 key 或者是遍历联合类型</li><li>条件类型 T extends U ? X : Y 经常用于一些类型不确定的情况 根据T是否为U的子集 决定使用的类型</li></ul><h4>装饰器</h4><ul> 不用在该源代码的情况下 修改内容 <li>类 修改实例的方法访问constructor.prototype 修改静态属性 直接访问数据</li><li>方法/属性</li><li>参数</li><li>访问器</li><li>装饰器工厂 装饰器返回一个函数</li></ul><h4>type 和 interface 的区别</h4><ul><li>interface 可选属性，只读属性，索引类型，类类型，多余属性检查</li><li>interface 可以合并 可以实现 可以继承</li><li>type 起别名 起别名不会新建类型 使用 &amp; 合并 </li><li>type 可以用到更多的类型，Type可以计算属性，生成映射类型</li></ul>",18)];const u={};var c=(0,e(83744).Z)(u,[["render",function(l,i){return(0,t.wg)(),(0,t.iD)("section",null,n)}]])}}]);