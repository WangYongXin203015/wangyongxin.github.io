"use strict";(self.webpackChunkvue=self.webpackChunkvue||[]).push([[9776],{59776:function(e,n,r){r.r(n),r.d(n,{default:function(){return d}});var t=r(66252),a=r(3577),c=(0,t._)("h4",null,"WebGPUStart",-1),o=(0,t.Uk)(""),i=(0,t.Uk)("\r\n");const s={};var d=(0,r(83744).Z)(s,[["render",function(e,n){var r=(0,t.Q2)("code");return(0,t.wg)(),(0,t.iD)("section",null,[c,(0,t.wy)(((0,t.wg)(),(0,t.iD)("pre",null,[o,(0,t._)("code",null,"\r\n    //环境 WebGPU还没有正式发布 使用chrome canary进行预览\r\n    //https://www.google.cn/intl/en_uk/chrome/canary/ 进行下载、\r\n    //chrome://flags/ 搜索 WebGPU，打开WebGPU功能\r\n    //新建index.html 添加\r\n    "+(0,a.zw)('<!DOCTYPE html>\n    <html lang="en">\n    <head>\n        <meta charset="UTF-8">\n        <meta http-equiv="X-UA-Compatible" content="IE=edge">\n        <meta name="viewport" content="width=device-width, initial-scale=1.0">\n        \x3c!-- <link rel="shortcut icon" type="image/icon" href="/favicon.ico"> --\x3e\n        <title><%= htmlWebpackPlugin.options.title %></title>\n    </head>\n    <body>\n        <canvas id="canvas" width="1000" height="618"></canvas>\n    </body>\n    <script>')+'\r\n        async function render() {\r\n            // const canvas =document.querySelector("#Canvas")\r\n            //创建一个adapter\r\n            const adapter = await navigator.gpu.requestAdapter({powerPreference:"high-performance"});\r\n            //获取设备\r\n            const device = await adapter.requestDevice();\r\n            // 创建一个WebGPU Canvas Context实例\r\n            const context  = canvas.getContext(\'webgpu\');\r\n            // 然后需要声明图像色彩格式，比如brga8unorm，即用8位无符号整数和rgba来表示颜色，从adapter中也能直接获取\r\n            const format =navigator.gpu.getPreferredCanvasFormat();\r\n\r\n            context.configure({\r\n                device,\r\n                format,\r\n                usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,\r\n                alphaMode:"premultiplied"\r\n                \r\n            })\r\n            const cmdEncoder =device.createCommandEncoder();\r\n            const textureView =context.getCurrentTexture().createView(); // 获取画布上的纹理视图，将WebGPU渲染出的图像显示到画布上\r\n            // 创建一个渲染通道 RenderPass\r\n\r\n            const texture = device.createTexture({\r\n                size: [1000,618],\r\n                sampleCount: 4,\r\n                format: navigator.gpu.getPreferredCanvasFormat(),\r\n                usage: GPUTextureUsage.RENDER_ATTACHMENT,\r\n            });\r\n            const renderPassDescriptor = {\r\n                colorAttachments: [\r\n                {\r\n                    resolveTarget:context.getCurrentTexture().createView(),\r\n                    view:  texture.createView(),\r\n                    loadOp:"clear",\r\n                    storeOp: \'store\',\r\n                }, \r\n                ]\r\n            }\r\n            const vertex='+(0,a.zw)("`\n            @vertex\n            fn main(@builtin(vertex_index) VertexIndex : u32) -> @builtin(position) vec4<f32> {\n                var pos = array<vec2<f32>, 3>(\n                    vec2<f32>(-0.5, -0.5),\n                    vec2<f32>(0.5,-0.5),\n                    vec2<f32>(0.5, 0.5),\n                );\n                return vec4<f32>(pos[VertexIndex], 0.0, 1.0);\n            }`")+"\r\n\r\n            const fragment="+(0,a.zw)("`\n            @fragment\n            fn main() -> @location(0) vec4<f32> {\n                return vec4<f32>(1.0, 0.0, 0.0, 1.0);\n            }`")+"\r\n\r\n            const pipeline =device.createRenderPipeline({\r\n                // vertex:指定了对应的顶点着色器\r\n                vertex: {\r\n                    module:device.createShaderModule({\r\n                        code: vertex, // 顶点着色器代码\r\n                    }),\r\n                    entryPoint: 'main', // 入口函数\r\n                },\r\n                // fragment：指定了片元着色器\r\n                fragment: {\r\n                    module:device.createShaderModule({\r\n                        code: fragment, // 片元着色器代码\r\n                    }),\r\n                    entryPoint: 'main',\r\n                    targets: [\r\n                        {\r\n                            format: format, // 即上文的最终渲染色彩格式\r\n                        },\r\n                    ],\r\n                },\r\n                // primitive：指定需要绘制的图元类型\r\n                primitive: {\r\n                    topology: \"triangle-list\", // 按照三角形绘制\r\n                },\r\n                multisample:{\r\n                    count:4 \r\n                },\r\n                layout:\"auto\"\r\n            });\r\n\r\n            const renderPassEncoder= cmdEncoder.beginRenderPass(renderPassDescriptor);\r\n            renderPassEncoder.setPipeline(pipeline);\r\n            renderPassEncoder.draw(3, 1, 0, 1);\r\n            renderPassEncoder.end();  //录制结束\r\n            device.queue.submit([cmdEncoder.finish()])//结束绘制\r\n        }\r\n        render()\r\n\r\n    "+(0,a.zw)("<\/script>\n    </html>")+"\r\n    //在浏览器中打开html 查看效果\r\n",1),i])),[[r]])])}]])}}]);