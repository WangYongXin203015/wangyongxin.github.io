"use strict";(self.webpackChunkvue=self.webpackChunkvue||[]).push([[7897],{57897:function(l,i,u){u.r(i),u.d(i,{default:function(){return s}});var t=u(66252),e=[(0,t.uE)("<h4>函数式编程和面向对象</h4><ul><li>OO 数据存放在属性中和静态成员中</li><li>函数式 数据存放在 各级作用域中</li></ul><h4>继承 Inheritance</h4><ul>\x3c!-- &lt;li&gt;拥有相同属性和方法不需要多次重复的书写&lt;/li&gt; --\x3e<li>函数式 <ul><li>rust 子类实现一个父类的实例</li><li>子类调用父类的构造函数</li><li> js继承 <ul>原型链继承 <li>父类的实例作为子类的原型</li><li>无法实现多继承</li><li>子类的实例属性 易于添加 </li><li>原型属性添加 必须在父类实例创建之后 之前添加的会被覆盖</li><li>创建子类实例的时候不能向父类构造函数传参</li></ul><ul> 借用构造函数继承 <li>解决了子类构造函数向父类构造函数中传递参数</li><li>可以实现多继承（call或者apply多个父类）</li><li>将别人的方法和属性直接拿来用</li><li>不能继承原型属性/方法，只能继承父类的实例属性和方法</li></ul><ul>组合式继承 <li>调用父类构造函数，继承父类的属性 借用继承</li><li>父类实例是子类原型</li><li>调用了两次 父类的构造方法</li></ul><ul> 寄生组合继承 <li>借用构造函数继承父类属性</li><li>将super 函数的原型指向父类的原型</li><li>实例化super 将super的原型挂载到当前构造函数的原型上</li></ul><ul> class继承 <li>定义的属性和方法全部在原型上</li><li>super 调用父类的方法</li></ul></li></ul></li><li>面向对象 class继承</li></ul><h4>多态</h4><ul><li>函数式 <ul><li>trait 每个Struct 实现自己的trait</li><li>子类直接重写同名方法</li></ul></li><li>子类指针指向父类根据子类的方法不同调用不同的方法 父类是虚函数只有声明不需要实现</li></ul><h4>封装</h4><ul><li>向外暴露接口，内部隐藏，外部调用方法</li><li></li></ul>",8)];const r={};var s=(0,u(83744).Z)(r,[["render",function(l,i){return(0,t.wg)(),(0,t.iD)("section",null,e)}]])}}]);