"use strict";(self.webpackChunkvue=self.webpackChunkvue||[]).push([[858],{30858:function(i,e,t){t.r(e),t.d(e,{default:function(){return a}});var l=t(66252),r=[(0,l.uE)("<h4>iter迭代器</h4><ul><li>IntoIterator::into_iter</li><li>iter.next() 访问下一个</li><li>iter.size_hint() 惰性的 元组的第一个元素是未迭代元素数量的下界，第二个元素是未迭代元素的上界。</li><li>iter().count() 计算迭代次数</li><li>iter().last() 返回最后的数据</li><li>iter.advance_by(index) 跳过index个迭代器不够Err</li><li>iter.nth(index) 返回第index个迭代器，多次调用不会返回迭代器</li><li>iter().chain() 合并两个迭代器 后加</li><li>ietr().zip() 合并迭代器返回新的迭代器是元组类型</li><li>iter().intersperse(ele) 在迭代器中插入ele，first form iter，last form iter</li><li>iter().map(F) 接受一个闭包，对每个元素使用闭包,返回一个新的迭代器</li><li>iter().for_each(F) 相当于for循环</li><li>iter().filter(F) 闭包返回true 返回该元素</li><li>iter().filter_map(F) 返回的迭代器只包括返回值为true，返回新的迭代器，可操作</li><li>iter().enumerate() 返回index和value的元组</li><li>iter().peekable() 返回一个新的迭代器，用iter.peek()和peek_mut()可以访问当前元素</li><li>iter().skip_while(F) 传递一个闭包 返回新的迭代器类似于filter</li><li>iter().take_while(F) 传递一个闭包 返回新的迭代器类似于filter</li><li>iter().scan(stateValue,| state,x|{}) 传递一个初始state和闭包返回一个新的iter</li><li>iter().flat_map() map之后的扁平化处理</li><li>iter().flatten() 扁平化一层</li><li>iter().fuse() 使用后 在第一次返回None之后简化一直返回None</li><li>iter().collect() 转换为集合</li><li>iter().min() 最小值</li><li>iter().max() 大值</li><li>iter().rev() 反转</li><li>iter().reduce(F | state, item |) 传递闭包寻找合适的元素, state 初始状态，item元素</li><li>iter().partition(F) 返回元组 第一个元素是满足条件的集合，第二个是不满足的集合</li></ul>",2)];const n={};var a=(0,t(83744).Z)(n,[["render",function(i,e){return(0,l.wg)(),(0,l.iD)("section",null,r)}]])}}]);